#include <cstdlib>
#include <iostream>
#include "interpolator.hpp"
using namespace std;

double privateInterp(const point& left, const point& right, double angle) {
  if (left.r == 0 or right.r == 0) return 0;
  return (angle - left.theta)/(right.theta - left.theta) *
    (right.r - left.r) + left.r;
}

void interpolate(const vector<point>& points, int output[],
		 size_t n, double delta) {

  // special case: 0 degrees uses first and last data point
  point left = points.back();
  point right = points.front();
  left.theta -= 360;  // produces a negative angle
  output[0] = privateInterp(left, right, 0);

  point farRight = right;
  farRight.theta += 360;
  
  size_t currentLeftIndex = 0;

  double angle = delta;
  for(size_t i = 1; i < n; i++) {
    // search for two points that bracket angle
    while(currentLeftIndex < points.size() - 1 &&
	  !(
	    points[currentLeftIndex].theta < angle
	    && points[currentLeftIndex + 1].theta >= angle))
      currentLeftIndex++;    
    left = points[currentLeftIndex];
    right = currentLeftIndex == points.size() - 1 ? farRight : points[currentLeftIndex + 1];

    // debugging output...make sure angle is correct
    //cout << left.theta << " < " << angle << " <= " << right.theta << endl;
    output[i] = privateInterp(left, right, angle);
    angle += delta;
  }
}
